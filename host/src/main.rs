// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use db_access::queries::get_block_headers_by_block_range;
use db_access::DbConnection;
use dotenv::dotenv;
use eyre::Result;
use methods::PRICING_CALCULATOR_ELF;
use methods_volatility::GUEST_VOLATILITY_ELF;
use risc0_zkvm::{default_prover, ExecutorEnv};
use tokio::task;
use core::VolatilityInputs;

async fn run_host(
    start_block: i64,
    end_block: i64,
) -> Result<(Option<f64>, Option<f64>, Option<f64>), sqlx::Error> {
    dotenv().ok();
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let db = DbConnection::new().await?;
    let block_headers = get_block_headers_by_block_range(&db.pool, start_block, end_block).await?;

    let prove_info = task::spawn_blocking(move || {
        let env = ExecutorEnv::builder()
            .write(&block_headers)
            .unwrap()
            .build()
            .unwrap();
        let prover = default_prover();
        prover.prove(env, PRICING_CALCULATOR_ELF).unwrap()
    })
    .await
    .unwrap();

    let receipt = prove_info.receipt;

    let (volatility, twap, reserve_price): (Option<f64>, Option<f64>, Option<f64>) =
        receipt.journal.decode().unwrap();

    println!("HOST");
    println!("Volatility: {:?}", volatility);
    println!("TWAP: {:?}", twap);
    println!("Reserve Price: {:?}", reserve_price);

    Ok((volatility, twap, reserve_price))
}

fn hex_string_to_f64(hex_str: &String) -> Result<f64> {
    let stripped = hex_str.trim_start_matches("0x");
    u128::from_str_radix(stripped, 16)
        .map(|value| value as f64)
        .map_err(|e| eyre::eyre!("Error converting hex string '{}' to f64: {}", hex_str, e))
}

async fn run_host_volatility(start_block: i64, end_block: i64) -> Result<Option<f64>, sqlx::Error> {
    dotenv().ok();
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let db = DbConnection::new().await?;
    let block_headers = get_block_headers_by_block_range(&db.pool, start_block, end_block).await?;
    let base_fee_per_gases_hex: Vec<Option<String>> = block_headers
        .iter()
        .map(|header| header.base_fee_per_gas.clone())
        .collect();
    let base_fee_per_gases: Vec<Option<f64>> = base_fee_per_gases_hex
        .iter()
        .map(|hexes| {
            if let Some(hex) = hexes {
                return Some(hex_string_to_f64(hex).unwrap());
            } else {
                return None;
            }
        })
        .collect();

    let mut results: Vec<f64> = Vec::new();
    for i in 1..base_fee_per_gases.len() {
        if let (Some(ref basefee_current), Some(ref basefee_previous)) =
            (&base_fee_per_gases[i], &base_fee_per_gases[i - 1])
        {
            // Convert base fees from hex string to f64
            // let basefee_current = hex_string_to_f64(basefee_current).unwrap();
            // let basefee_previous = hex_string_to_f64(basefee_previous).unwrap();

            // If the previous base fee is zero, skip to the next iteration
            if *basefee_previous == 0.0 {
                continue;
            }

            // Calculate log return and add it to the returns vector
            results.push((*basefee_current / *basefee_previous).ln());
        }
    }

    let volatility_inputs = VolatilityInputs {
        base_fee_per_gases: base_fee_per_gases.clone(),
        ln_results: results,
    };

    let prove_info = task::spawn_blocking(move || {
        let env = ExecutorEnv::builder()
            .write(&volatility_inputs)
            .unwrap()
            .build()
            .unwrap();
        let prover = default_prover();
        prover.prove(env, GUEST_VOLATILITY_ELF).unwrap()
    })
    .await
    .unwrap();

    let receipt = prove_info.receipt;

    let volatility: Option<f64> = receipt.journal.decode().unwrap();

    Ok(volatility)
}

#[tokio::main]
async fn main() -> Result<(), sqlx::Error> {
    // run_host(20000000, 20000170).await?;
    // run_host(20000000, 20000200).await?;
    // 3 months data
    // run_host(20000000, 20700000).await?;
    run_host_volatility(20000000, 20002000).await?;
    Ok(())
}
