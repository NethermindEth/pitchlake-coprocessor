# Quick Start Guide

## Minimal Example

Here's the minimal code to generate a proof from your external application:

```rust
use proof_composition::generate_reserve_price_proof;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. Get your data (5760 hours = 240 days of hourly gas prices)
    let gas_prices: Vec<f64> = fetch_your_data()?;

    // 2. Define time period (90 days)
    let now = chrono::Utc::now().timestamp();
    let start = now - (90 * 24 * 3600);
    let end = now;

    // 3. Generate proof (takes 6-10 minutes)
    let receipt = generate_reserve_price_proof(
        gas_prices,
        start,
        end,
        15000  // strike price in gwei
    )?;

    // 4. Extract results
    let output = receipt.journal.decode()?;
    println!("Reserve Price: {}", output.reserve_price);

    Ok(())
}
```

## What You Need

### Input Data: `data_8_months: Vec<f64>`

- **Format**: Vector of 5760 floating-point numbers
- **Meaning**: Hourly average gas prices in gwei for 240 days
- **Example**: `[15.5, 16.2, 14.8, ...]`

### Time Periods

```rust
// 90-day period for reserve price calculation
let start_timestamp: i64 = 1708833600;  // Unix timestamp
let end_timestamp: i64 = start_timestamp + (90 * 24 * 3600);
```

### Strike Price

```rust
let strike_price: i64 = 15000;  // In gwei (15 gwei = 15,000,000,000 wei)
```

## Understanding ProofCompositionInput

The system automatically constructs this struct for you, but here's what it contains:

### Core Fields (You Provide)

| Field | Your Input | Example |
|-------|------------|---------|
| `data_8_months` | Historical gas prices | `vec![15.5, 16.2, ...]` (5760 values) |
| `start_timestamp` | Analysis start time | `1708833600` |
| `end_timestamp` | Analysis end time | `1708833600 + (90*24*3600)` |

### Computed Fields (System Generates)

All other fields in `ProofCompositionInput` are computed automatically:

- `data_8_months_hash` - Generated by hashing function
- `positions`, `pt`, `pt_1` - From reserve price calculation
- `season_param`, `twap_7d` - From time series analysis
- `reserve_price` - The main output
- All tolerance values - Configured defaults

## Data Flow Diagram

```
Your Application
     │
     ├─ data_8_months: Vec<f64> ────────────┐
     ├─ start_timestamp: i64 ────────────────┤
     ├─ end_timestamp: i64 ──────────────────┤
     └─ strike_price: i64 ───────────────────┤
                                              │
                                              ▼
                                 generate_reserve_price_proof()
                                              │
                    ┌─────────────────────────┴──────────────────────────┐
                    │                                                     │
         [Hashing] [Max Return] [TWAP] [Seasonality] [Transitions] [Simulation]
                    │                                                     │
                    └─────────────────────────┬──────────────────────────┘
                                              │
                                              ▼
                                   ProofCompositionInput
                                   (automatically built)
                                              │
                                              ▼
                                      ZK Proof Generation
                                              │
                                              ▼
                                         Receipt
                                              │
                                              ▼
                              ┌───────────────┴───────────────┐
                              │   ProofCompositionOutput      │
                              ├───────────────────────────────┤
                              │ - reserve_price               │
                              │ - twap_result                 │
                              │ - max_return                  │
                              │ - data_8_months_hash          │
                              │ - timestamps & tolerances     │
                              └───────────────────────────────┘
```

## Field Mappings

Here's how your input maps to `ProofCompositionInput`:

```rust
ProofCompositionInput {
    // ══════════════════════════════════════════════════════
    // FROM YOUR INPUT
    // ══════════════════════════════════════════════════════
    data_8_months: your_gas_prices,
    start_timestamp: your_start,
    end_timestamp: your_end,

    // ══════════════════════════════════════════════════════
    // COMPUTED - HASHING
    // ══════════════════════════════════════════════════════
    data_8_months_hash: hash_felts(your_gas_prices).hash,

    // ══════════════════════════════════════════════════════
    // COMPUTED - TIMESTAMP RANGES
    // ══════════════════════════════════════════════════════
    data_8_months_start_timestamp: your_start - (5 * 30 * 24 * 3600),
    data_8_months_end_timestamp: your_end,
    twap_start_timestamp: your_start,
    twap_end_timestamp: your_end,
    reserve_price_start_timestamp: your_start,
    reserve_price_end_timestamp: your_end,
    max_return_start_timestamp: your_start - (5 * 30 * 24 * 3600),
    max_return_end_timestamp: your_end,

    // ══════════════════════════════════════════════════════
    // COMPUTED - RESERVE PRICE CALCULATION
    // ══════════════════════════════════════════════════════
    // Result from: calculate_reserve_price(data, strike, n_periods)
    positions: res.positions,
    pt: res.pt,
    pt_1: res.pt_1,
    de_seasonalised_detrended_log_base_fee: res.de_seasonalised_detrended_log_base_fee,
    season_param: res.season_param,
    twap_7d: res.twap_7d,
    slope: res.slope,
    intercept: res.intercept,
    reserve_price: res.reserve_price,

    // ══════════════════════════════════════════════════════
    // COMPUTED - TWAP
    // ══════════════════════════════════════════════════════
    twap_result: calculate_twap(data_3_months),

    // ══════════════════════════════════════════════════════
    // COMPUTED - MAX RETURN
    // ══════════════════════════════════════════════════════
    max_return: max_return(data_8_months).1,

    // ══════════════════════════════════════════════════════
    // CONSTANTS - SIMULATION PARAMETERS
    // ══════════════════════════════════════════════════════
    n_periods: 720,              // 720 three-hour periods in 90 days
    num_paths: 4000,             // Monte Carlo simulation paths

    // ══════════════════════════════════════════════════════
    // CONSTANTS - TOLERANCES
    // ══════════════════════════════════════════════════════
    gradient_tolerance: 0.05,           // 5%
    floating_point_tolerance: 0.00001,  // 0.00001%
    reserve_price_tolerance: 5.0,       // 5%
    twap_tolerance: 1.0,                // 1%
}
```

## Common Questions

### Q: Do I need to build ProofCompositionInput myself?

**No!** The `generate_reserve_price_proof()` function builds it for you. Just provide:
1. Gas price data (Vec<f64>)
2. Start timestamp (i64)
3. End timestamp (i64)
4. Strike price (i64)

### Q: What if I want to customize tolerances?

Modify the function or create your own version:

```rust
pub fn generate_custom_proof(
    data: Vec<f64>,
    start: i64,
    end: i64,
    strike: i64,
    custom_gradient_tol: f64,  // Your custom value
) -> Result<Receipt, Box<dyn std::error::Error>> {
    // ... (same code but use custom_gradient_tol)
}
```

### Q: Can I compute fields incrementally?

Yes! You can break it down:

```rust
// Step 1: Compute hash
let (hash_receipt, hash_result) = hash_felts(data);

// Step 2: Compute max return
let (max_ret_receipt, max_ret) = max_return(data);

// Step 3: Compute reserve price
let reserve_result = calculate_reserve_price(data, strike, 720);

// Step 4: Build input manually
let input = ProofCompositionInput {
    data_8_months: data,
    data_8_months_hash: hash_result.hash,
    positions: reserve_result.positions,
    max_return: max_ret.1,
    // ... fill in the rest
};
```

### Q: Where does each field come from?

| Field Group | Source Function | Module |
|-------------|-----------------|---------|
| Hash | `hash_felts()` | `hashing_felts` |
| Max Return | `max_return()` | `max_return_floating` |
| TWAP | `calculate_twap()` | `twap_error_bound_floating` |
| Reserve Price | `calculate_reserve_price()` | `common::original` |
| Timestamps | Your input + calculations | N/A |
| Tolerances | Constants | N/A |

## Production Checklist

Before going to production, ensure:

- [ ] Data has exactly 5760 values (240 days × 24 hours)
- [ ] All gas prices are positive (> 0)
- [ ] Time period is approximately 90 days
- [ ] You have 8-16 GB RAM available
- [ ] Allow 6-10 minutes for proof generation
- [ ] Store the receipt for on-chain submission
- [ ] Test with mock data first

## Next Steps

1. **Read the full guide**: See `PROOF_COMPOSITION_GUIDE.md`
2. **Check the example**: See `examples/external_integration.rs`
3. **Run tests**: `cargo test`
4. **Generate your first proof**: Use the minimal example above
5. **Deploy on-chain**: Set up RISC Zero verifier on Starknet

## Support

- Check commented code in `mains/*/src/main.rs`
- See full documentation in `PROOF_COMPOSITION_GUIDE.md`
- Review example in `examples/external_integration.rs`
